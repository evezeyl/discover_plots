---
title: "Discover plots and tables"
author: "Eve Zeyl Fiskebeck"
date: "`r format(Sys.time(), '%d %B, %Y')`"
params:
    data: "data/Cleaned_data_for_publication_STEC_isolate_inventory_WGS_20250205.xlsx"
    sheet: "Cleaned_data" 
    source_code: 'code/R'
execute: 
  echo: false
  cache: false
format: html
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>" 
    R.options:
      knitr.graphics.auto_pdf: true
editor_options: 
  chunk_output_type: console
---

- added Renv

```{r setup}
#| include: false
library(here)
library(readxl)
library(dplyr)
library(readr)
library(stringr)
library(ggplot2)
library(ggalluvial)
library(ggfittext)
library(tidyr)
library(purrr)
library(svglite)
library(ggrepel)
library(gt)
library(webshot2)

#library(janitor)
#library(gtExtras)
#library(gtsummary)
# magick

```

# Data check and cleaning 

NOTE: The data is not clean - This is not normal (you should provide the data set with a table that can be used directly in an analysis software - so the formating should be rechecked)

```{r}
data1 <- readxl::read_excel(here::here(params$data),
                           sheet = params$sheet,
                           na = "NA")
glimpse(data1) 
```

# Data pretifying & for homogeneity for all datasets

```{r}
data <- 
  data1 %>%
  # Source added
  mutate(Source = if_else(Source.Group == "Human", Source.Group , "Non Human"),
         n = 1) %>%
  # Additional column stx classification vs detail
  rename(stx.subtype_detail = stx.subtype) %>%
  mutate(stx.subtype = case_when(
    str_detect(stx.subtype_detail, "stx1") & str_detect(stx.subtype_detail, "stx2") ~ "stx1;stx2",
    str_detect(stx.subtype_detail, "stx1") & !str_detect(stx.subtype_detail, "stx2") ~ "stx1",
    str_detect(stx.subtype_detail, "stx2") & !str_detect(stx.subtype_detail, "stx1") ~ "stx2",
    TRUE ~ NA)) %>% 
  # pathogenecity island re-encoding
  mutate(eae = if_else(eae.y =="0", "Abscent", "Present")) %>%
  # rename col - homogeneity
  rename(SeroType.H = Serotype.H)

# add here if other things detected and rerun
  
```

# Data selection - to ease making graphs (and only cleaning what I must)

- based on lab data 
```{r}
# lab then sequence fields - that is why organized like that
# last those I do not think I will use but keep anyway for now
selected_data <- 
  data %>% 
  select(Country, Source.Group, 
         Disease := `Disease..only.human.isolates.`,
         MLST, 
         stx.subtype, stx.subtype_detail,
         stx.other.method :=`stx_subtypes identified by other methods`,
         Serotype.O := SeroType.O, SeroType.H, SeroTypeOH := O_H_combined_serotype, eae, eae.y,
         AMR.genes,
         Source, 
         Source.Subgroup, Year.Isolation, Institute, Isolate.ID,
         n
) 
glimpse(selected_data)
View(selected_data)
```


# Data quality check 


## Function to create summary table 
```{r summary table function}
# function for fast reuse of summary
my_summary_fun <- function(data) {
  data %>%
    select(-Isolate.ID, -AMR.genes) %>%
    mutate_all(factor) %>%
    summary(., maxsum = 400) %>%
    as.data.frame.matrix(row.names = NULL) %>% 
    mutate_all(~coalesce(., "")) %>%
    `rownames<-`( NULL ) 
}

```

### Data check for homogeneity 

```{r}
summary_table <- 
  selected_data %>% 
  my_summary_fun()  

View(summary_table)
```

### Previous data check for info
> not needed anymore 

<!-- 
## Data control helpers
```{r}
selected_data %>%
  select(MLST) %>%
  distinct() %>%
  View()
```


THIS IS TO BE CHECKED : **Homoegeneizing NAs** 
_Ask for treatment_


- [x] Serotype O -> ONT = O Non typeable. O112ab, bc osv treated at different serotypes
- [x] Serotype H -> HNT = H Non typeable 

OK, I think we can let as is 
But for the column O:H serotype -> We leave as ONT:HNT possibilities (because we want it clear)

Need to homogeneize what is uncertain.
Could have done in beginning but prefer control

Camilla has fixed the MLST

- [x] eae  -> presence / abscence re-encoded

- [x] Data homogeneization 

Unknown disease its because its only for humans, while NA its not applicable
- so we week Unknown as is


```{r replacement function}
# Function to detect pattern in a cell and replace it by something else (eg. NA)
replace_with_XX <- function(astring, patterns, XX) {
  
  ## XX is what should the thing replaced with 
  
  # Test if there is a match with the cell to any replacement pattern
  replace_decision <- 
    any(unlist(
      lapply(patterns, function(x) grepl(x, astring))
      ))
  # True then replace with NA 
  ifelse(replace_decision, XX, astring)
}
```


```{r}
# The NA is already NA so we do not need to add (would mess up system)
NAs <- c("^ONT$", "^HNT$", "^ND$" )


# I finished to use Unknown as its more practical for the graph
homegeneized_data <- 
  selected_data %>%
  mutate(across(everything(), 
                ~ purrr::map_vec(., replace_with_XX, NAs, "Unknown")
         )) %>%
  # Now I need to replace NA also 
  mutate(across(everything(), 
                ~ purrr::map_vec(., function(x) ifelse(is.na(x), "Unknown",x))
         ))
  
  
```

--> 

### Data control 
Control 
```{r}
selected_data %>% 
  my_summary_fun() %>%
  View()
```

### Export summary statistics
```{r}
write.table(selected_data %>% 
              select( -n ) %>%
              my_summary_fun(),
            here("results", "2025-02-06_summary_table_col.tsv"),
            sep = "\t", 
            col.names = T, row.names = F,
            quote = F)
```


# Genes AMR and virulence checks - remove from data 
What data is inside (I did not look before)


```{r}
data_col <- 
  data %>% 
  names()

data_col

list_gene_data <- data_col[which (data_col == "asta"):which (data_col == "irea")]
length(list_gene_data)

list_gene_fine <-c('asta', 'ipad', 'saa', 'agg3a', 'cif', 'espj', 'toxb', 'aggd', 'lpfa', 'cfac', 'agg3d', 'katp', 'espa', 'ltca', 'cnf1', 'espc', 'espb', 'aata', 'agg4c', 'tccp', 'stx1a', 'ipah9', 'lnga', 'tir', 'cdtb', 'iss', 'espf', 'tsh', 'espp', 'virf', 'agg5a', 'sfas', 'k88ab', 'bfpa', 'efa1', 'capu', 'agga', 'eila', 'pic', 'cma', 'vat', 'agg4d', 'agg4a', 'cci', 'siga', 'aar', 'stx2a', 'ehxa', 'mchb', 'senb', 'aafd', 'iha', 'aggc', 'stx2b', 'fim41a', 'etpd', 'fasa', 'mcma', 'nleb', 'aafa', 'nlea', 'sat', 'feda', 'nfae', 'iron', 'suba', 'pet', 'pera', 'aafc', 'air', 'agg3c', 'aaic', 'eae', 'epea', 'gad', 'sepa', 'rpea', 'hlye', 'fedf', 'aap', 'orf4', 'aggr', 'f17a', 'nlec', 'orf3', 'cba', 'fana', 'stb', 'aafb', 'mchc', 'eata', 'sta1', 'agg3b', 'mchf', 'aggb', 'stx1b', 'f17g', 'celb', 'cofa', 'espi', 'agg4b', 'irea')

length(list_gene_fine)

setdiff(list_gene_fine, list_gene_data)

```

102 genes consistent between reports AMR and list in script for the pipeline. 

But Camilla mentione 145 - incl. virulotyper -> found db - check which genes are searched additionally

```{r}
virulotyper_genes<- readr::read_tsv(here::here("results", "sequences_list_virulotyper"), col_names = "gene" )

virulotyper_genes <- 
  virulotyper_genes %>%
  mutate_at(.vars = "gene", ~str_remove(., "^>")) %>%
  separate(gene, into = "gene", sep = "_", extra = "drop") %>%
  distinct() %>%
  pull()

length(virulotyper_genes)
```

145 genes in virulotyper

- finding those in virulotyper that are not in AMR
```{r}
diff_virulence <- setdiff(virulotyper_genes, list_gene_fine)
dput(diff_virulence)

length(diff_virulence)
```

checking reporting of AMR data : if 0 or contains also ND

```{r}
AMR_data <- 
  data[,26:127] %>%
  mutate_all(factor)

AMR_data %>%
  summary(., maxsum = 400) %>%
    as.data.frame.matrix(row.names = NULL) %>% 
    mutate_all(~coalesce(., "")) %>%
    `rownames<-`( NULL )  %>%
  View()
```

- only 0 So no ND 

### Genes with only 0

checking columns wich have only 0 -> so we can remove those from the data
we need to have the levels
```{r}
nb_rows <- as.character(nrow(AMR_data))
nb_rows
sum_AMR_data <- 
  AMR_data %>%
  mutate_all(as.character) %>%
  # Ensuring that we can differentiate from NA
  mutate_all(~str_replace(.x, "0", "1")) %>%
  mutate_all(as.numeric) %>%
  summarise_all(~sum(.x, na.rm = T)) %>%
  t() %>%
  tibble::as_tibble(rownames = "gene") %>%
  mutate_all(as.character)

# now we have those to remove
remove_AMR <- 
  sum_AMR_data %>%
  filter(V1 == nb_rows) %>%
  pull(gene)
  
dput(remove_AMR)
#data$ipad
length(remove_AMR)
```
28 genes ... to be removed (cf Output data for Camilla)


## Update DATA remove 0 genes

```{r}
dim(data)
data <- 
  data %>%
  # remove genes with 0 
  select(!remove_AMR) 
  
```


# Table FOR Shiga Toxin Gene

## Global table 
```{r}
#Shiga 
stx_all <- 
  selected_data %>%
  select(stx := stx.subtype, stx.subtype := stx.subtype_detail, Source) %>%
  mutate_all(~if_else(is.na(.), "ND", .)) %>%
  mutate(stx.subtype = str_remove_all(stx.subtype, " "),
         stx = factor(stx, levels = c("stx1", "stx2", "stx1;stx2", "ND"), ordered = T)) %>%
  group_by(stx, stx.subtype, Source) %>%
  tally() %>%
  tidyr::spread(Source, value = n, fill = 0) 
  
stx_all
```


Export Complete Shiga 
```{r}
write.table(stx_all,
            here("results", "2025-02-06_stx_all.tsv"),
            sep = "\t", 
            col.names = T, row.names = F,
            quote = F)
```


now we need to reduce the table 
- grouping <= 10 if in human or non human

```{r}
stx_compact <- 
  stx_all %>%
  ungroup() %>%
  mutate(stx.subtype = case_when(
    Human >= 10 | `Non Human` >= 10 ~ stx.subtype,
    TRUE ~ "Other"
  ))%>%
  group_by(stx, stx.subtype) %>%
  arrange(stx, stx.subtype)

stx_compact %>% View()



# dput(sort(unique(stx_compact$stx.subtype)))  
stx_sub_levels <- 
  c("stx1a", "stx1c",  "stx1d", 
    "stx2a", "stx2b", "stx2c", "stx2d", "stx2e", "stx2f", "stx2g", 
    "stx2a;stx2c", "stx2a;stx2c;stx2d", 
    "stx1a;stx2a", "stx1a;stx2b", "stx1a;stx2c", "stx1a;stx2d", "stx1c;stx2b",
    "stx2a;stx2b",
    "Other", "ND", "Total")


stx_compact_total <- 
  stx_compact %>%
  ungroup() %>%
  mutate(stx.subtype = factor(stx.subtype, levels = stx_sub_levels, ordered = T)) %>%
  group_by(stx, stx.subtype) %>%
  summarise(Human := sum(Human), `Non Human`:= sum(`Non Human`), .groups = "keep") 

stx_compact_total %>% View()
```

## Tables with sums 
Adding sums per stx
```{r}
sums_stx <- 
  stx_compact_total %>%
  ungroup() %>%
  group_by(stx) %>%
  summarise(Human := sum(Human), `Non Human`:= sum(`Non Human`), .groups = "keep") %>%
  mutate(stx.subtype = "Total", .after = "stx") %>%
  mutate(stx.subtype = factor(stx.subtype, levels = stx_sub_levels, ordered = T)) %>%
  # we remove ND because it will be the same 
  filter(stx != "ND")

# Now merging so we can have display 
stx_compact_total <- 
  stx_compact_total %>%
  bind_rows(sums_stx) %>% 
  arrange(stx) 

stx_compact_total %>% View()

# Output for an eventual manual formatting
# write.table(stx_compact_total,
#             here("results", "2025-02-06_stx_compact_Total.tsv"),
#             sep = "\t", 
#             col.names = T, row.names = F,
#             quote = F)


```

## simple pretty table with gt

https://gt.rstudio.com/
https://jthomasmock.github.io/gtExtras/
https://themockup.blog/static/slides/intro-tables.html#26
```{r}
stx_gt_table <- 
  stx_compact_total %>% 
  ungroup() %>%
  gt(rowname_col = "stx.subtype",
     groupname_col = "stx", 
     process_md = TRUE, 
     row_group_as_column = TRUE,
     rownames_to_stub = FALSE) %>%
  #opt_table_lines(extent = "none") %>%
  opt_table_lines(extent = "default") %>%
  tab_header(title = md("**Table 2:** Stx genes and stx subtypes identified in human and non-human sources.")) %>%
  tab_spanner(label =  "Source", 
              columns = c(Human, `Non Human`)) %>%
  # gt::summary_rows(
  #   groups = TRUE,
  #   columns = c(`Human`, `Non Human`),
  #   fns = list(Sum = ~sum(.))
  #   ) # does no tappear to work so manual
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ), 
    locations = cells_row_groups( ) ) %>%
  # tab_style(
  #   style = list(), 
  #   locations = cells_body(
  #   columns = crop
  #     )) %>% 
  cols_align(
    align = "left") 
  

# gt::basic_theme()
# https://themockup.blog/posts/2020-09-26-functions-and-themes-for-gt-tables/#gt-themes
# basic_theme()? 
# 
# stubhead.label
# stub 
# tab_
# row_group()
  
```

## Export

```{r}
stx_gt_table

gtsave(stx_gt_table, "stx_gt_table.png", here::here("results"))
```

# Parallel sets (Sankey like) plots (I want adding to 100 %)
Now I used ggalluvial 

## Prepare data - first exploration
```{r}
parallel_data1 <- 
  data %>%
  select(Source, eae, stx := stx.subtype, SeroTypeOH := O_H_combined_serotype, n) %>%
  # reformating for better display
  mutate(Source = str_replace(Source, "Non human", "Non\nHuman")) %>%
  mutate(stx = str_remove_all(stx, " ")) %>%
  mutate(stx = str_replace(stx, ";", "\n")) %>%
  mutate(`%` = n / sum(n) * 100) %>%
  # We need this column twice (under different names)
  mutate(Origin  = Source) %>%
  # trying to order to make the graph a bit clearer
  arrange(Source, eae, stx, SeroTypeOH) 

glimpse(parallel_data)
```

data check 
- stx with NA 
```{r}
parallel_data1 %>%
  mutate_all(factor) %>%
    summary(., maxsum = 400) %>%
    as.data.frame.matrix(row.names = NULL) %>% 
    mutate_all(~coalesce(., "")) %>%
    `rownames<-`( NULL ) %>%
  View()

```


### Long format first exploration exploration
Transform to long format, as it appears to be better to adjust the plot
```{r}
parallel_data_long1 <- 
  parallel_data1 %>%
  # so all the columns we want to show in alluvial need to be in long format
  # But not the fill which is source
  to_lodes_form(key = "col",
                axes = c("Origin", "eae", "stx", "SeroTypeOH"),
                value = "stratum",
                id = "alluvium") 
head(parallel_data_long1)
View(parallel_data_long1)
```


First view of the plot (here I did not filter aex)

```{r}
# to be able to resize the text we need to go to long format
global_parallel_plot1 <- 
  parallel_data_long1 %>%
  ggplot(.,
         aes(x = col, y = `%`,
             stratum = stratum, 
             alluvium = alluvium,
             label = stratum)) +
  geom_alluvium(aes(fill = Source)) +
  geom_stratum() + 
  # Need to be first
  ggrepel::geom_text_repel(
    data = parallel_data_long %>%
      filter(col == "stx" & is.na(stratum)), 
    aes(label = "NA"),
    stat = "stratum", size = 3, direction = "y", nudge_x = -.5) +
  # need to be second
   geom_fit_text(
       stat = "stratum", min.size = 1) +
  ggtitle("Percentage of isolates belonging to the classicaly typing systems") + 
  theme_minimal() 

global_parallel_plot1
```


```{r}
ggsave(filename = here::here("results", "global_parallel_plot1.png"),
       plot = global_parallel_plot1,
       dpi = 300,
       units = "cm",
       width = 30, height = 10) 
```



## Preparing for final plotting - order and grouping some variables 

```{r}
dput(unique(unique(parallel_data1$stx)))
dput(unique(unique(parallel_data1$eae)))


source_levels <- unique(parallel_data1$Source)
eae_levels <- c("Present", "Abscent")
stx_levels <- c("stx1", "stx2", "stx1\nstx2", NA)

sero_count <- 
  parallel_data1 %>%
  select(SeroTypeOH, n) %>%
  group_by(SeroTypeOH) %>%
  summarise(sero_sum := sum(n), .groups = "keep") %>%
  arrange(desc(sero_sum)) %>%
  mutate(sero_transfo = if_else(sero_sum >= 50, SeroTypeOH, "Other"))

# those are those to group as Other
sero_other <- 
  sero_count %>% 
    filter(sero_transfo == "Other") %>%
    pull(SeroTypeOH)

length(sero_other)
dput(sero_other)


# order levels
sero_levels <- 
  sero_count %>%
  filter(sero_transfo != "Other") %>%
  pull(SeroTypeOH)

sero_levels <- c(sero_levels, "Other")
```

Now I can get the data set with the groups and ordered levels 

```{r}
parallel_data2 <- 
  parallel_data1 %>%
  # Needs to be done first - because otherwise levels will not be changed
  mutate(SeroTypeOH  = if_else(SeroTypeOH %in% sero_other, "Other", SeroTypeOH)) %>%
  # it needs to be Origin that is ordered - its the one used in the stash for plot
  mutate(Origin = factor(Source, levels = source_levels, ordered = T),
         eae = factor(eae, levels = eae_levels, ordered = T),
         stx = factor(stx, levels = stx_levels, ordered = T),
         SeroTypeOH = factor(SeroTypeOH, levels = sero_levels, ordered = T))
```


### Long format data for final 

```{r}
parallel_data_long2 <- 
  parallel_data2 %>%
  # so all the columns we want to show in alluvial need to be in long format
  # But not the fill which is source
  to_lodes_form(key = "col",
                axes = c("Origin", "eae", "stx", "SeroTypeOH"),
                value = "stratum",
                id = "alluvium") 
```


### Final Plot

```{r}
# to be able to resize the text we need to go to long format
global_parallel_plot2 <- 
  parallel_data_long2 %>%
  # mutate(text_size = case_when(
  #   col == "Origin" | col == "eae" | col == "stx" ~ 1,
  #   col == "SeroTypeOH" ~ 1,
  #   TRUE ~ .3)
  #   ) %>%
  ggplot(.,
         aes(x = col, y = `%`,
             stratum = stratum, 
             alluvium = alluvium,
             label = stratum)) +
  geom_alluvium(aes(fill = Source)) +
  #geom_stratum(width = 1/2) +
  geom_stratum() + 
  # Need to be first
  ggrepel::geom_text_repel(
    data = parallel_data_long %>%
      filter(col == "stx" & is.na(stratum)), 
    aes(label = "NA"),
    stat = "stratum", size = 3, direction = "y", nudge_x = -.5) +
  # need to be second
   geom_fit_text(
       stat = "stratum", min.size = 1) +
  # aes(label = ifelse(col == "stx" & is.na(stratum), "NA", NA)),
  #  stat = "stratum", size = 1, direction = "y", nudge_x = -.5) +
  ggtitle("Percentage of isolates belonging to the classicaly typing systems") + 
  theme_minimal() 

global_parallel_plot2

```




# Export the plot 
Curious seems that gemo_fit_text does not work nice with export in gg...
Export manually and works best
```{r}
# ggsave(filename = here::here("results", "global_parallel_plot.svg"),
#        plot = global_parallel_plot,
#        dpi = 300,
#        units = "cm",
#        width = 30, height = 10)
ggsave(filename = here::here("results", "global_parallel_plot2.png"),
       plot = global_parallel_plot,
       dpi = 300,
       units = "cm",
       width = 30, height = 10) 
```


# Output data for Camilla 

```{r}
dim(data)
data %>%
  # remove genes with 0 
  select(!remove_AMR) %>%
  
```


