---
title: "Discover plots and tables"
author: "Eve Zeyl Fiskebeck"
date: "`r format(Sys.time(), '%d %B, %Y')`"
params:
    data: "data/Cleaned_data_for_publication_STEC_isolate_inventory_WGS_20250205.xlsx"
    sheet: "Cleaned_data" 
    source_code: 'code/R'
execute: 
  echo: false
  cache: false
format: html
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>" 
    R.options:
      knitr.graphics.auto_pdf: true
editor_options: 
  chunk_output_type: console
---

- added Renv

```{r setup}
#| include: false
library(here)
library(readxl)
library(dplyr)
library(readr)
library(stringr)
library(ggplot2)
library(ggalluvial)
library(ggfittext)
library(tidyr)
library(purrr)
library(svglite)
#library(janitor)
library(gt)
#library(gtExtras)
library(webshot2)

#library(gtsummary)
# magick

```

# Data check and cleaning 

NOTE: The data is not clean - This is not normal (you should provide the data set with a table that can be used directly in an analysis software - so the formating should be rechecked)

```{r}
data <- readxl::read_excel(here::here(params$data),
                           sheet = params$sheet,
                           na = "NA")
glimpse(data) 
```

data selection - to ease making graphs (and only cleaning what I must)

- based on lab data 
```{r}
# lab then sequence fields - that is why organized like that
# last those I do not think I will use but keep anyway for now
selected_data <- 
  data %>% 
  mutate(Source = if_else(Source.Group == "Human", Source.Group , "Non Human"),
         n = 1) %>%
  rename(stx.subtype_detail = stx.subtype) %>%
  mutate(stx.subtype = case_when(
    str_detect(stx.subtype_detail, "stx1") & str_detect(stx.subtype_detail, "stx2") ~ "stx1;stx2",
    str_detect(stx.subtype_detail, "stx1") & !str_detect(stx.subtype_detail, "stx2") ~ "stx1",
    str_detect(stx.subtype_detail, "stx2") & !str_detect(stx.subtype_detail, "stx1") ~ "stx2",
    TRUE ~ NA)) %>% 
  mutate(eae = if_else(eae.y =="0", "Abscent", "Present")) %>%
  select(Country, Source.Group, 
         Disease := `Disease..only.human.isolates.`,
         MLST, 
         stx.subtype, stx.subtype_detail,
         stx.other.method :=`stx_subtypes identified by other methods`,
         Serotype.O := SeroType.O, Serotype.H, SerotypeOH := O_H_combined_serotype, eae, eae.y,
         AMR.genes,
         Source, 
         Source.Subgroup, Year.Isolation, Institute, Isolate.ID,
         n
) 
glimpse(selected_data)
View(selected_data)
```


# Data quality check 


## Function to create summary table 
```{r summary table function}
# function for fast reuse of summary
my_summary_fun <- function(data) {
  data %>%
    select(-Isolate.ID, -AMR.genes) %>%
    mutate_all(factor) %>%
    summary(., maxsum = 400) %>%
    as.data.frame.matrix(row.names = NULL) %>% 
    mutate_all(~coalesce(., "")) %>%
    `rownames<-`( NULL ) 
}

```

### Data check for homogeneity 

```{r}
summary_table <- 
  selected_data %>% 
  my_summary_fun()  

View(summary_table)
```

### Previous data check for info
> not needed anymore 

<!-- 
## Data control helpers
```{r}
selected_data %>%
  select(MLST) %>%
  distinct() %>%
  View()
```


THIS IS TO BE CHECKED : **Homoegeneizing NAs** 
_Ask for treatment_


- [x] Serotype O -> ONT = O Non typeable. O112ab, bc osv treated at different serotypes
- [x] Serotype H -> HNT = H Non typeable 

OK, I think we can let as is 
But for the column O:H serotype -> We leave as ONT:HNT possibilities (because we want it clear)

Need to homogeneize what is uncertain.
Could have done in beginning but prefer control

Camilla has fixed the MLST

- [x] eae  -> presence / abscence re-encoded

- [x] Data homogeneization 

Unknown disease its because its only for humans, while NA its not applicable
- so we week Unknown as is


```{r replacement function}
# Function to detect pattern in a cell and replace it by something else (eg. NA)
replace_with_XX <- function(astring, patterns, XX) {
  
  ## XX is what should the thing replaced with 
  
  # Test if there is a match with the cell to any replacement pattern
  replace_decision <- 
    any(unlist(
      lapply(patterns, function(x) grepl(x, astring))
      ))
  # True then replace with NA 
  ifelse(replace_decision, XX, astring)
}
```


```{r}
# The NA is already NA so we do not need to add (would mess up system)
NAs <- c("^ONT$", "^HNT$", "^ND$" )


# I finished to use Unknown as its more practical for the graph
homegeneized_data <- 
  selected_data %>%
  mutate(across(everything(), 
                ~ purrr::map_vec(., replace_with_XX, NAs, "Unknown")
         )) %>%
  # Now I need to replace NA also 
  mutate(across(everything(), 
                ~ purrr::map_vec(., function(x) ifelse(is.na(x), "Unknown",x))
         ))
  
  
```

--> 

### Data control 
Control 
```{r}
selected_data %>% 
  my_summary_fun() %>%
  View()
```

### Export summary statistics
```{r}
write.table(selected_data %>% 
              select( -n ) %>%
              my_summary_fun(),
            here("results", "2025-02-05_summary_table.tsv"),
            sep = "\t", 
            col.names = T, row.names = F,
            quote = F)
```


## genes AMR and virulence checks 
What data is inside (I did not look before)

```{r}
data_col <- 
  data %>% 
  names()

data_col
length(data_col[26:127])

list_gene_fine <-c('asta', 'ipad', 'saa', 'agg3a', 'cif', 'espj', 'toxb', 'aggd', 'lpfa', 'cfac', 'agg3d', 'katp', 'espa', 'ltca', 'cnf1', 'espc', 'espb', 'aata', 'agg4c', 'tccp', 'stx1a', 'ipah9', 'lnga', 'tir', 'cdtb', 'iss', 'espf', 'tsh', 'espp', 'virf', 'agg5a', 'sfas', 'k88ab', 'bfpa', 'efa1', 'capu', 'agga', 'eila', 'pic', 'cma', 'vat', 'agg4d', 'agg4a', 'cci', 'siga', 'aar', 'stx2a', 'ehxa', 'mchb', 'senb', 'aafd', 'iha', 'aggc', 'stx2b', 'fim41a', 'etpd', 'fasa', 'mcma', 'nleb', 'aafa', 'nlea', 'sat', 'feda', 'nfae', 'iron', 'suba', 'pet', 'pera', 'aafc', 'air', 'agg3c', 'aaic', 'eae', 'epea', 'gad', 'sepa', 'rpea', 'hlye', 'fedf', 'aap', 'orf4', 'aggr', 'f17a', 'nlec', 'orf3', 'cba', 'fana', 'stb', 'aafb', 'mchc', 'eata', 'sta1', 'agg3b', 'mchf', 'aggb', 'stx1b', 'f17g', 'celb', 'cofa', 'espi', 'agg4b', 'irea')

length(list_gene_fine)
```

102 genes consistent between reports AMR and list in script for the pipeline. 

But Camilla mentione 145 - incl. virulotyper -> found db - check which genes are searched additionally

```{r}
virulotyper_genes<- readr::read_tsv(here::here("results", "sequences_list_virulotyper"), col_names = "gene" )

virulotyper_genes <- 
  virulotyper_genes %>%
  mutate_at(.vars = "gene", ~str_remove(., "^>")) %>%
  separate(gene, into = "gene", sep = "_", extra = "drop") %>%
  distinct() %>%
  pull()

length(virulotyper_genes)
```

145 genes in virulotyper

- finding those in virulotyper that are not in AMR
```{r}
diff_virulence <- setdiff(virulotyper_genes, list_gene_fine)
dput(diff_virulence)

length(diff_virulence)
```

checking reporting of AMR data : if 0 or contains also ND

```{r}
AMR_data <- 
  data[,26:127] %>%
  mutate_all(factor)

AMR_data %>%
  summary(., maxsum = 400) %>%
    as.data.frame.matrix(row.names = NULL) %>% 
    mutate_all(~coalesce(., "")) %>%
    `rownames<-`( NULL )  %>%
  View()
```

- only 0 So no ND 

### Genes with only 0

checking columns wich have only 0 -> so we can remove those from the data
we need to have the levels
```{r}
nb_rows <- as.character(nrow(AMR_data))
nb_rows
sum_AMR_data <- 
  AMR_data %>%
  mutate_all(as.character) %>%
  # Ensuring that we can differentiate from NA
  mutate_all(~str_replace(.x, "0", "1")) %>%
  mutate_all(as.numeric) %>%
  summarise_all(~sum(.x, na.rm = T)) %>%
  t() %>%
  tibble::as_tibble(rownames = "gene") %>%
  mutate_all(as.character)

# now we have those to remove
remove_AMR <- 
  sum_AMR_data %>%
  filter(V1 == nb_rows) %>%
  pull(gene)
  
dput(remove_AMR)
#data$ipad
length(remove_AMR)
```
28 genes ... to be removed (cf Output data for Camilla)


# Data wrangling & make tables and graphs


## Table for Shiga Toxin Gene

### Global table 
```{r}
#Shiga 
stx_all <- 
  selected_data %>%
  select(stx := stx.subtype, stx.subtype := stx.subtype_detail, Source) %>%
  mutate_all(~if_else(is.na(.), "ND", .)) %>%
  mutate(stx.subtype = str_remove_all(stx.subtype, " "),
         stx = factor(stx, levels = c("stx1", "stx2", "stx1;stx2", "ND"), ordered = T)) %>%
  group_by(stx, stx.subtype, Source) %>%
  tally() %>%
  tidyr::spread(Source, value = n, fill = 0) 
  
stx_all
```


Export Complete Shiga 
```{r}
write.table(stx_all,
            here("results", "2025-02-06_stx_all.tsv"),
            sep = "\t", 
            col.names = T, row.names = F,
            quote = F)
```


now we need to reduce the table 
- grouping <= 10 if in human or non human

```{r}
stx_compact <- 
  stx_all %>%
  ungroup() %>%
  mutate(stx.subtype = case_when(
    Human >= 10 | `Non Human` >= 10 ~ stx.subtype,
    TRUE ~ "Other"
  ))%>%
  group_by(stx, stx.subtype) %>%
  arrange(stx, stx.subtype)

stx_compact %>% View()



# dput(sort(unique(stx_compact$stx.subtype)))  
stx_sub_levels <- 
  c("stx1a", "stx1c",  "stx1d", 
    "stx2a", "stx2b", "stx2c", "stx2d", "stx2e", "stx2f", "stx2g", 
    "stx2a;stx2c", "stx2a;stx2c;stx2d", 
    "stx1a;stx2a", "stx1a;stx2b", "stx1a;stx2c", "stx1a;stx2d", "stx1c;stx2b",
    "stx2a;stx2b",
    "Other", "ND", "Total")


stx_compact_total <- 
  stx_compact %>%
  ungroup() %>%
  mutate(stx.subtype = factor(stx.subtype, levels = stx_sub_levels, ordered = T)) %>%
  group_by(stx, stx.subtype) %>%
  summarise(Human := sum(Human), `Non Human`:= sum(`Non Human`), .groups = "keep") 

stx_compact_total %>% View()
```

### Tables with sums 
Adding sums per stx
```{r}
sums_stx <- 
  stx_compact_total %>%
  ungroup() %>%
  group_by(stx) %>%
  summarise(Human := sum(Human), `Non Human`:= sum(`Non Human`), .groups = "keep") %>%
  mutate(stx.subtype = "Total", .after = "stx") %>%
  mutate(stx.subtype = factor(stx.subtype, levels = stx_sub_levels, ordered = T)) %>%
  # we remove ND because it will be the same 
  filter(stx != "ND")

# Now merging so we can have display 
stx_compact_total <- 
  stx_compact_total %>%
  bind_rows(sums_stx) %>% 
  arrange(stx) 

stx_compact_total %>% View()

# Output for an eventual manual formatting
write.table(stx_compact_total,
            here("results", "2025-02-06_stx_compact_Total.tsv"),
            sep = "\t", 
            col.names = T, row.names = F,
            quote = F)


```

### simple pretty table with gt

https://gt.rstudio.com/
https://jthomasmock.github.io/gtExtras/
https://themockup.blog/static/slides/intro-tables.html#26
```{r}
stx_gt_table <- 
  stx_compact_total %>% 
  ungroup() %>%
  gt(rowname_col = "stx.subtype",
     groupname_col = "stx", 
     process_md = TRUE, 
     row_group_as_column = TRUE,
     rownames_to_stub = FALSE) %>%
  #opt_table_lines(extent = "none") %>%
  opt_table_lines(extent = "default") %>%
  tab_header(title = md("**Table 2:** Stx genes and stx subtypes identified in human and non-human sources.")) %>%
  tab_spanner(label =  "Source", 
              columns = c(Human, `Non Human`)) %>%
  # gt::summary_rows(
  #   groups = TRUE,
  #   columns = c(`Human`, `Non Human`),
  #   fns = list(Sum = ~sum(.))
  #   ) # does no tappear to work so manual
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ), 
    locations = cells_row_groups( ) ) %>%
  # tab_style(
  #   style = list(), 
  #   locations = cells_body(
  #   columns = crop
  #     )) %>% 
  cols_align(
    align = "left") 
  

# gt::basic_theme()
# https://themockup.blog/posts/2020-09-26-functions-and-themes-for-gt-tables/#gt-themes
# basic_theme()? 
# 
# stubhead.label
# stub 
# tab_
# row_group()
  
```


```{r}
stx_gt_table

gtsave(stx_gt_table, "stx_gt_table.png", here::here("results"))
```


## Parallel sets (Sankey like) plots (I want adding to 100 %)

```{r}
homegeneized_data %>%
  glimpse()

# To be able to resize and adjust it appears that long format will be easier
long_data <- 
  homegeneized_data %>%
  select(-Isolate.ID) %>%
  mutate(Source = 
           ifelse(Source.Group == "Human", Source.Group, "Non\nhuman")
         ) %>%
  mutate_at(vars(stx), ~str_replace(., ";", "\n")) %>%
  mutate(nbrow = 1) %>%
  mutate(`%` = nbrow / sum(nbrow) * 100) %>%
  select(-Source.Group, -Institute, -Source.Subgroup, -nbrow) %>%
  # trying to order to make the graph a bit clearer
  arrange(Source, eae.x, stx, O.group, H.type, MLST) %>% 
  mutate(Origin  = Source) %>%
  # so all the columns we want to show in alluvial need to be in long format
  # But not the fill 
  to_lodes_form(key = "col",
                axes = c("Origin", "eae.x", "stx", "O.group","H.type", "MLST"),
                value = "stratum",
                id = "alluvium") 
head(long_data)
View(long_data)
```


```{r}
# to be able to resize the text we need to go to long format
global_parallel_plot <- 
  long_data %>%
  mutate(text_size = case_when(
    col == "Origin" | col == "eae.x" | col == "stx" ~ 1,
    col == "O.group" | col == "H.type" ~ 1,
    TRUE ~ .3)
    ) %>% 
  ggplot(., 
       aes(x = col, y = `%`,
           stratum = stratum, 
           alluvium = alluvium,
           label = stratum)) + 
  geom_alluvium(aes(fill = Source)) +
  #geom_stratum(width = 1/2) +
  geom_stratum() + 
  geom_fit_text(stat = "stratum", min.size = 1) +
  ggtitle("Percentage of isolates belonging to the classicaly typing systems") + 
  theme_minimal() 
```

Export the plot 
Curious seems that gemo_fit_text does not work nice with export in gg...
Export manually and works best
```{r}
# ggsave(filename = here::here("results", "global_parallel_plot.svg"),
#        plot = global_parallel_plot,
#        dpi = 300,
#        units = "cm",
#        width = 30, height = 10)
ggsave(filename = here::here("results", "global_parallel_plot2.png"),
       plot = global_parallel_plot,
       dpi = 300,
       units = "cm",
       width = 30, height = 10) 
```


# Output data for Camilla 

```{r}
dim(data)
data %>%
  # remove genes with 0 
  select(!remove_AMR) %>%
  # rename col - homogeneity
  rename(SeroType.H = Serotype.H) %>%
  # Source added
  mutate(Source = if_else(Source.Group == "Human", Source.Group , "Non Human"),
         n = 1) %>%
  # Additional column stx classification vs detail
  rename(stx.subtype_detail = stx.subtype) %>%
  mutate(stx.subtype = case_when(
    str_detect(stx.subtype_detail, "stx1") & str_detect(stx.subtype_detail, "stx2") ~ "stx1;stx2",
    str_detect(stx.subtype_detail, "stx1") & !str_detect(stx.subtype_detail, "stx2") ~ "stx1",
    str_detect(stx.subtype_detail, "stx2") & !str_detect(stx.subtype_detail, "stx1") ~ "stx2",
    TRUE ~ NA)) %>% 
  # pathogenecity island re-encoding
  mutate(eae = if_else(eae.y =="0", "Abscent", "Present")) %>%
```


